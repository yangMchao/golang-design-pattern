# 抽象工厂模式

抽象工厂模式用于生成产品族的工厂，所生成的对象是有关联的。

如果抽象工厂退化成生成的对象无关联则成为工厂函数模式。

比如本例子中使用 `RDB` 和 `XML` 存储订单信息，抽象工厂分别能生成相关的主订单信息和订单详情信息。 如果业务逻辑中需要替换使用的时候只需要改动工厂函数相关的类就能替换使用不同的存储方式了。



# 工厂模式（Factory Pattern）与抽象工厂模式（Abstract Factory Pattern）

## 概述

工厂模式和抽象工厂模式都是面向对象设计原则中创建型设计模式的重要成员，它们的主要目的是在创建对象时提供更大的灵活性和解耦性。尽管两者在目标和实现上有所重叠，但它们各自适用的场景和解决的问题有所不同。

## 相同之处

### 创建对象

- **解耦实例化**：两种模式都旨在将对象的实例化过程从客户端代码中解耦出来，使得客户端代码不需要直接知道如何创建具体对象。

### 抽象接口

- **定义接口**：它们都使用抽象接口（或抽象类）来定义对象的创建方法。客户端通过接口与具体工厂进行交互，而不是直接实例化对象。

### 封装变化

- **提高可维护性**：通过封装对象的创建过程，两种模式都使得客户端代码与具体对象的创建细节分离，从而提高代码的可维护性和扩展性。

## 不同之处

### 作用范围

- **工厂模式**：专注于创建一个单一类型的对象。通过一个具体工厂类来创建一个具体产品类的实例。
- **抽象工厂模式**：专注于创建一系列相关的或相互依赖的对象，即一个产品族。它通过一个抽象工厂类来创建一组具有相同主题或相互依赖的产品对象。

### 对象族

- **工厂模式**：创建的对象属于同一产品等级结构中的一员，即同一类型的不同实现。
- **抽象工厂模式**：创建的对象属于多个产品等级结构中的一组相关产品，这些产品通常是相互关联的，构成了一个产品族。

### 结构复杂度

- **工厂模式**：结构相对简单，通常只涉及一个抽象产品接口和一个或多个具体产品类，以及一个具体工厂类。
- **抽象工厂模式**：结构更为复杂，涉及多个抽象产品接口、多个具体产品类，以及一个抽象工厂接口和多个具体工厂类。

### 可扩展性

- **工厂模式**：当需要添加新的具体产品时，只需扩展新的具体产品类和相应的具体工厂类。客户端代码通常不需要修改。
- **抽象工厂模式**：当需要添加新的产品族时，需要扩展抽象工厂接口以及所有相关的具体工厂类和具体产品类。这种扩展可能会影响到整个系统的多个部分，因此设计时需要更加谨慎。
