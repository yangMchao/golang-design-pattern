# 适配器模式 (Adapter Pattern)

适配器模式是一种结构型设计模式，它允许不兼容的接口之间进行协作。适配器模式通过将一个类的接口转换成客户端期望的另一个接口，使得原本由于接口不兼容而不能一起工作的类可以协同工作。

## 意图

- 将现有接口转换为客户端期望的接口
- 允许不兼容的接口类一起工作
- 重用现有类，避免修改已有代码

## 适用场景

- 需要使用现有类，但其接口不符合需求
- 需要创建一个可复用的类，该类可以与不相关或不可预见的类协同工作
- 需要适配多个不同的接口，而每个接口的实现方式不同

## 结构

### 参与者

- **Target（目标接口）**：客户端使用的特定领域接口
- **Client（客户端）**：与符合Target接口的对象协同工作的类
- **Adaptee（被适配者）**：需要适配的现有接口
- **Adapter（适配器）**：将Adaptee接口转换为Target接口

### 在Go中的实现特点

本示例展示了Go语言中适配器模式的简洁实现：

1. **接口定义**：
   - `Target`：客户端期望的接口
   - `Adaptee`：需要被适配的接口

2. **组合而非继承**：
   - 使用结构体嵌套（匿名组合）实现适配器
   - 避免了复杂的继承层次

3. **非入侵式适配**：
   - 通过接口组合实现适配，不影响原有实现
   - 符合Go的接口设计理念

## 代码分析

### Target接口
```go
type Target interface {
    Request() string
}
```

### Adaptee接口
```go
type Adaptee interface {
    SpecificRequest() string
}
```

### Adapter实现
```go
type adapter struct {
    Adaptee  // 匿名组合被适配者
}

func (a *adapter) Request() string {
    // 将SpecificRequest适配为Request
    return a.SpecificRequest()
}
```

### 使用示例
```go
// 创建被适配者
adaptee := NewAdaptee()

// 通过适配器包装
target := NewAdapter(adaptee)

// 使用统一的Target接口
result := target.Request()  // 实际调用adaptee.SpecificRequest()
```

## 优点

- **解耦**：客户端与具体类解耦，通过接口进行交互
- **灵活性**：可以动态地添加和切换适配器
- **复用性**：可以复用现有的类，无需修改其源代码
- **开闭原则**：添加新适配器不影响现有代码

## 缺点

- **复杂度增加**：需要额外的适配器类，增加了系统复杂度
- **间接性**：调用链路增加了一层，可能影响性能

## 与其他模式的关系

- **外观模式**：适配器模式是对已有接口的转换，外观模式是为复杂子系统提供统一接口
- **装饰器模式**：装饰器模式增强对象功能，适配器模式改变对象接口
- **代理模式**：代理模式提供相同的接口，适配器模式提供不同的接口

## Go语言特色

在Go语言中，适配器模式具有以下特点：

1. **隐式接口**：Go的接口是隐式实现的，适配器可以更容易地实现接口
2. **组合优于继承**：通过结构体嵌套实现组合，比继承更加灵活
3. **零值安全**：适配器可以安全地处理nil值
4. **并发安全**：可以设计并发安全的适配器实现
